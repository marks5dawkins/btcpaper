# -*- coding: utf-8 -*-
"""btcpaper.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1baQWrQf07dkYHLIIOxVbjOQDe3nmEGME
"""

# !pip install pmdarima
# !pip install git+https://github.com/PYFTS/pyFTS.git

# Commented out IPython magic to ensure Python compatibility.
import warnings
import requests
import pandas as pd
import numpy as np
import datetime as dt
import plotly.express as px
import plotly.graph_objects as go
import statsmodels.api as sm
import pmdarima as pm
import matplotlib.pyplot as plt
import os
from google.colab import files
from itertools import product
from sklearn import metrics
from pmdarima.arima.utils import ndiffs
from plotly.subplots import make_subplots
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf


from pyFTS.partitioners import Grid, partitioner
from pyFTS.benchmarks import Measures, ResidualAnalysis as ra
from pyFTS.common import FuzzySet, Util, Transformations, Membership as mf
from pyFTS.models import song, chen, yu, ismailefendi, sadaei, hofts, pwfts, cheng, hwang
from pyFTS.models.nonstationary import partitioners as nspart, nsfts, honsfts, cvfts, perturbation



# %matplotlib inline
warnings.filterwarnings("ignore")

class Modelo_Arima():
  def __init__(self, dataset, ar, i, ma, name):
    self.__dataset = dataset
    self.__n_pred = int(len(self.__dataset) - 24*7)
    self.__train = self.__dataset[:self.__n_pred]
    self.__test = self.__dataset[self.__n_pred:]
    self.__ar = ar
    self.__i = i
    self.__ma = ma
    self.__name = name


  def Fit(self):
    model = sm.tsa.arima.ARIMA(self.__train, order=(self.__ar, self.__i, self.__ma))
    self.__model_fit = model.fit()
    print('                          Modelo ARIMA ' + self.__name)
    print(self.__model_fit.summary())

  def Diagnostics(self):
    print('                                 Grafica diagnostico modelo ARIMA ' + self.__name)
    self.__model_fit.plot_diagnostics(figsize=(15,10))
    plt.show()

  def Pronostico_Recursivo(self):
    nforecasts = 7*24
    forecasts = {}
    nobs = len(self.__dataset)
    model = sm.tsa.arima.ARIMA(self.__train, order=(self.__ar, self.__i, self.__ma))
    model_fit = model.fit()
    forecasts[self.__train.index[-1]] = model_fit.forecast(steps=nforecasts)
    

    for t in range(self.__n_pred, nobs):
      updated_forc = self.__dataset.iloc[t:t+1]
      model_fit = model_fit.extend(updated_forc)
      forecasts[updated_forc.index[0]] = model_fit.forecast(steps=nforecasts)

    forc = pd.concat(forecasts, axis=1)
    forc = forc[:len(self.__test)]
    forc_1 = forc.to_numpy()
    forc_f = np.diag(forc_1)
    forc_fx = pd.DataFrame(forc_f, columns = [self.__name] )
    forc_ff = forc_fx.copy()
    forc_ff.index += (len(self.__dataset) - nforecasts)
    forc_ff['Precio'] = self.__test
    forc_ff.reset_index(inplace=True)
    self.__forc = forc_ff

    title = "Predicciones ARIMA " +  self.__name
    fig = px.line(self.__forc,
                  y= [self.__name,
                      'Precio'],
                  width=1600,
                  height=550,
                  title=title)
    fig.update_xaxes(title_text='t')
    fig.update_yaxes(title_text='Precio')
    fig.show()

  def Metricas(self):
    mae = 'MAE ' + self.__name
    mape = 'MAPE ' + self.__name
    mse = 'MSE ' + self.__name
    rmse = 'RMSE ' + self.__name
    accuracy_p = pd.DataFrame(columns = ['Name', mae, mape, mse, rmse] )
    rows = []
    MAE = metrics.mean_absolute_error(self.__test, self.__forc['Pre-Pandemia'])
    MAPE = metrics.mean_absolute_percentage_error(self.__test, self.__forc['Pre-Pandemia'])
    MSE = metrics.mean_squared_error(self.__test, self.__forc['Pre-Pandemia'])
    RMSE = np.sqrt(metrics.mean_absolute_error(self.__test, self.__forc['Pre-Pandemia']))   
    rows = ['Arima RP', MAE, MAPE, MSE, RMSE]
    accuracy_p.loc[len(accuracy_p)] = rows
    return accuracy_p

class Modelos_FTS():
  def __init__(self, dataset, name):
    self.__levels =  ['BJ','AC','AL']
    self.__methods = [song.ConventionalFTS, 
        chen.ConventionalFTS, 
        yu.WeightedFTS, 
        ismailefendi.ImprovedWeightedFTS, 
        cheng.TrendWeightedFTS, 
        sadaei.ExponentialyWeightedFTS, 
        hofts.HighOrderFTS, 
        hofts.WeightedHighOrderFTS, 
        hwang.HighOrderFTS, 
        pwfts.ProbabilisticWeightedFTS]
    self.__ns_methods = [nsfts.NonStationaryFTS,
              nsfts.WeightedNonStationaryFTS,
              honsfts.HighOrderNonStationaryFTS]
    self.__dataset = dataset
    self.__n_pred = int(len(self.__dataset) - 24*7)
    self.__train = self.__dataset[:self.__n_pred]
    self.__test = self.__dataset[self.__n_pred:]
    self.__name = name
    self.__names = []
    sublevels = [str(k) for k in np.arange(0,5)]
    for combination in product(*[self.__levels, sublevels]):
      self.__names.append(combination[0]+combination[1])


  def Predicciones_FTS(self):
    tdiff = Transformations.Differential(2)
    sublevels = [str(k) for k in np.arange(0,5)]
    self.__names = []
    for combination in product(*[self.__levels, sublevels]):
      self.__names.append(combination[0]+combination[1])


    fs = Grid.GridPartitioner(data=self.__test, func= mf.gaussmf, npart=15, transformation=tdiff, names=self.__names)

    ns_fs = nspart.SimpleNonStationaryPartitioner(self.__train, fs, location=perturbation.polynomial, location_params=[1, 0],
                                                  location_roots=0, width=perturbation.polynomial, width_params=[1, 0], width_roots=0)
    fts = pd.DataFrame(self.__test, columns = ['Price'] )

    for method in self.__methods:
      models = method(partitioner=fs)
      models.append_transformation(tdiff)
      models.fit(self.__train)
      forecast = models.predict(self.__test)
      while len(forecast) < 168:
        forecast.insert(0,None)
      else:
        c = str(models.shortname)
        fts[c] = forecast


    for method in self.__ns_methods:
      models = method(partitioner=ns_fs)
      models.fit(self.__train)
      forecast = models.predict(self.__test)
      while len(forecast) < 168:
        forecast.insert(0,None)
      else:
        c = str(models.shortname)
        fts[c] = forecast


    self.__fts_predicctions = fts
    title = "predicciones FTS " + self.__name
    fig = px.line(self.__fts_predicctions,
                  y= ['Price',
                      'FTS',
                      'CFTS',
                      'WFTS',
                      'IWFTS',
                      'TWFTS',
                      'EWFTS',
                      'HOFTS',
                      'WHOFTS',
                      'Hwang',
                      'PWFTS',
                      'NSFTS',
                      'WNSFTS',
                      'HONSFTS'],
                  width=1600,
                  height=550,
                  title=title)
    fig.update_xaxes(title_text='t')
    fig.update_yaxes(title_text='Price')
    fig.show()
  
  def Conjuntos(self):
    tdiff = Transformations.Differential(2)
    fs = Grid.GridPartitioner(data=self.__test, func= mf.gaussmf, npart=15, transformation=tdiff, names=self.__names)
    fig, ax = plt.subplots(nrows=1, ncols=1, figsize=[15,5])
    fs.plot(ax)

  def Reglas(self):
    tdiff = Transformations.Differential(2)
    fs = Grid.GridPartitioner(data=self.__test, func= mf.gaussmf, npart=15, transformation=tdiff, names=self.__names)
    model = chen.ConventionalFTS(partitioner=fs)
    model.append_transformation(tdiff)
    model.fit(self.__dataset)
    print(model)


  def Metricas(self):
    self.__fts_predicctions = self.__fts_predicctions.fillna(self.__test[0])
    mae = 'MAE ' + self.__name
    mape = 'MAPE ' + self.__name
    mse = 'MSE ' + self.__name
    rmse = 'RMSE ' + self.__name
    accuracy_p = pd.DataFrame(columns = ['Name', mae, mape, mse, rmse] )
    models_check = [self.__fts_predicctions['FTS'], self.__fts_predicctions['CFTS'], self.__fts_predicctions['WFTS'],
                    self.__fts_predicctions['IWFTS'], self.__fts_predicctions['TWFTS'], self.__fts_predicctions['EWFTS'],
                    self.__fts_predicctions['HOFTS'], self.__fts_predicctions['WHOFTS'], self.__fts_predicctions['Hwang'],
                    self.__fts_predicctions['PWFTS']]
    rows = []
    for forecast in models_check:
      MAE = metrics.mean_absolute_error(self.__test, forecast)
      MAPE = metrics.mean_absolute_percentage_error(self.__test, forecast)
      MSE = metrics.mean_squared_error(self.__test, forecast)
      RMSE = np.sqrt(metrics.mean_absolute_error(self.__test, forecast))   
      rows = [forecast.name, MAE, MAPE, MSE, RMSE]
      accuracy_p.loc[len(accuracy_p)] = rows
    return accuracy_p

def get_candles(start='', symbol='BTCUSDT', tick_interval='1h', limit=35000):
    
    base_url = 'https://api.binance.com/'
    endpoint = 'api/v3/klines?'
    
    if start:
        query = 'symbol=' + symbol + '&interval=' + tick_interval + '&startTime=' + str(start) +'&limit='+str(limit)
    else:
        query = 'symbol=' + symbol + '&interval=' + tick_interval +'&limit='+str(limit)
        
    candles = requests.get(base_url + endpoint + query).json()
    
    return candles, candles[-1][6]

def get_all_candles_from_start(symbol, tick_interval):  # devuelve una lista de velas, cada vela es una lista tb
    
    start=16608  
    _, last_time = get_candles(start='', symbol=symbol , tick_interval=tick_interval, limit=1)
    
    candles = []
    while start < last_time:
        i_candles, next_hop = get_candles(start, symbol, tick_interval)
        candles = candles + i_candles
        start = next_hop
        
    return candles

def adf_test(timeseries):
    dftest = sm.tsa.stattools.adfuller(timeseries, autolag="AIC")
    dfoutput = pd.Series(
        dftest[0:4],
        index=[
            "Test Statistic",
            "p-value",
            "#Lags Used",
            "Number of Observations Used",
        ],
    )
    for key, value in dftest[4].items():
        dfoutput["Critical Value (%s)" % key] = value
    print(dfoutput)